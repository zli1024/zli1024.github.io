<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>相机噪声标定 | Zhilin&#39;s Blog</title>
<meta name="keywords" content="Noise, Calibration, Camera, Computational, Photography">
<meta name="description" content="相机噪声标定流程
第一部分：EMVA1288 相机的线性模型及噪声
像素曝光与相机的线性信号模型
首先，我们需要了解噪声生成的整个过程，并尝试建立一个物理噪声模型，以便进行噪声标定。下图（来自EMVA1288）给我们展示了一个相机的通用物理模型。

所谓的EMVA1288标准，是欧洲机器视觉委员会专门编写的关于数字图像传感器以及相机特性的量化评估标准。该标准历史悠久，我们现在采用的是最新的4.0版本，4.0版本分为了线性版和非线性版，其中线性版本就是针对我们日常使用的数码相机、手机、单反这样常规的相机数字图像传感器，而非线性版本则是指那些不符合线性曝光过程的相机。所以本文所指的EMVA1288主要是针对线性版来展开讲解。
从EMVA1288中我们知道，在整个相机电子系统中，由光照累积的电荷单位被转换为电压，经过放大，最终通过模数转换器（ADC）转换为数字信号$y$。而这整个过程可以看作是线性的，并且可以用具体的量来描述，如系统增益$K$（单位为$DN/e^{-}$，这里$DN$为Digital Number的缩写）等等。所以关于上图中的数字量$\mu_y$（平均像素值）可以建立如下公式：

$$
\mu_y = K(\mu_e &#43; \mu_d) \quad or \quad \mu_y = \mu_{y \cdot dark} &#43; K\mu_e  \qquad (1)
$$
而平均光子数$\mu_p=\frac{AEt_{exp}}{h\nu}=\frac{AEt_{exp}}{hc/\lambda}$，其中$A$为传感器面积，$E$是传感器表面在曝光时间$t_{exp}$ 内的光照度，单位为$W/m^2$，而平均电子数$\mu_e=\eta \mu_p$​，因此上述方程(1)可以转换为以下方程：

$$
\mu_y = \mu_{y\cdot dark} &#43; K\eta \mu_p = \mu_{y\cdot dark} &#43; K\eta\frac{\lambda A}{hc}Et_{exp}  \qquad (2)
$$噪声模型
散粒噪声（Shot noise）是泊松分布的，因此有$\sigma_{e}^2=\mu_e$；根据上图噪声生成模型所示，所有与传感器读出和放大电路相关的噪声源都可以用一个方差为 $\sigma_d^2$ 的与信号无关的正态分布噪声源来描述。最终的模数转换会在量化区间之间添加另一个均匀分布的噪声源，其方差为 $\sigma_q^2=1/12DN^2$。由于所有噪声源的方差线性相加，根据误差的传播规则，数字信号$y$ 的总时域方差(temporal variance)$\sigma_y^2$ 可以表示为：

$$
\sigma_y^2 = K^2(\sigma_d^2 &#43; \sigma_e^2) &#43; \sigma_q^2 \qquad (3)
$$
噪声可以与测量的平均数字信号相关联（利用公式(1)以及$\sigma_{e}^2=\mu_e$​）：

$$
\begin{matrix} \sigma_y^2 = \underbrace{K^2\sigma_d^2 &#43; \sigma_q^2} \qquad \\offset    \end{matrix}
\begin{matrix}&#43;\underbrace{K}(\mu_y-\mu_{y\cdot dark})\\slope \qquad \quad \qquad\end{matrix}  \qquad(4)
$$
这个方程是传感器特性表征的核心，根据噪声方差$\sigma_y^2$ 与光诱导数字信号均值$\mu_y - \mu_{y\cdot dark}$ 之间的线性关系，可以由斜率确定整体系统增益$K$，并从偏移量确定暗噪声方差$\sigma_d^2$ ，这种方法被称为光子转移方法（Photon Transfer Method）。">
<meta name="author" content="">
<link rel="canonical" href="https://zli1024.github.io/posts/%E7%9B%B8%E6%9C%BA%E5%99%AA%E5%A3%B0%E6%A0%87%E5%AE%9A/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b9bcbccf6ce8b8eff7bfb38d9eeaddd5afcd7224bc1632975b7be62322082868.css" integrity="sha256-uby8z2zouO/3v7ONnurd1a/NciS8FjKXW3vmIyIIKGg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zli1024.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zli1024.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zli1024.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zli1024.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zli1024.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://zli1024.github.io/posts/%E7%9B%B8%E6%9C%BA%E5%99%AA%E5%A3%B0%E6%A0%87%E5%AE%9A/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]      
    },
    loader:{
      load: ['ui/safe']
    },
  };
</script>

<meta property="og:url" content="https://zli1024.github.io/posts/%E7%9B%B8%E6%9C%BA%E5%99%AA%E5%A3%B0%E6%A0%87%E5%AE%9A/">
  <meta property="og:site_name" content="Zhilin&#39;s Blog">
  <meta property="og:title" content="相机噪声标定">
  <meta property="og:description" content="相机噪声标定流程 第一部分：EMVA1288 相机的线性模型及噪声 像素曝光与相机的线性信号模型 首先，我们需要了解噪声生成的整个过程，并尝试建立一个物理噪声模型，以便进行噪声标定。下图（来自EMVA1288）给我们展示了一个相机的通用物理模型。
所谓的EMVA1288标准，是欧洲机器视觉委员会专门编写的关于数字图像传感器以及相机特性的量化评估标准。该标准历史悠久，我们现在采用的是最新的4.0版本，4.0版本分为了线性版和非线性版，其中线性版本就是针对我们日常使用的数码相机、手机、单反这样常规的相机数字图像传感器，而非线性版本则是指那些不符合线性曝光过程的相机。所以本文所指的EMVA1288主要是针对线性版来展开讲解。
从EMVA1288中我们知道，在整个相机电子系统中，由光照累积的电荷单位被转换为电压，经过放大，最终通过模数转换器（ADC）转换为数字信号$y$。而这整个过程可以看作是线性的，并且可以用具体的量来描述，如系统增益$K$（单位为$DN/e^{-}$，这里$DN$为Digital Number的缩写）等等。所以关于上图中的数字量$\mu_y$（平均像素值）可以建立如下公式： $$ \mu_y = K(\mu_e &#43; \mu_d) \quad or \quad \mu_y = \mu_{y \cdot dark} &#43; K\mu_e \qquad (1) $$ 而平均光子数$\mu_p=\frac{AEt_{exp}}{h\nu}=\frac{AEt_{exp}}{hc/\lambda}$，其中$A$为传感器面积，$E$是传感器表面在曝光时间$t_{exp}$ 内的光照度，单位为$W/m^2$，而平均电子数$\mu_e=\eta \mu_p$​，因此上述方程(1)可以转换为以下方程： $$ \mu_y = \mu_{y\cdot dark} &#43; K\eta \mu_p = \mu_{y\cdot dark} &#43; K\eta\frac{\lambda A}{hc}Et_{exp} \qquad (2) $$噪声模型 散粒噪声（Shot noise）是泊松分布的，因此有$\sigma_{e}^2=\mu_e$；根据上图噪声生成模型所示，所有与传感器读出和放大电路相关的噪声源都可以用一个方差为 $\sigma_d^2$ 的与信号无关的正态分布噪声源来描述。最终的模数转换会在量化区间之间添加另一个均匀分布的噪声源，其方差为 $\sigma_q^2=1/12DN^2$。由于所有噪声源的方差线性相加，根据误差的传播规则，数字信号$y$ 的总时域方差(temporal variance)$\sigma_y^2$ 可以表示为： $$ \sigma_y^2 = K^2(\sigma_d^2 &#43; \sigma_e^2) &#43; \sigma_q^2 \qquad (3) $$ 噪声可以与测量的平均数字信号相关联（利用公式(1)以及$\sigma_{e}^2=\mu_e$​）： $$ \begin{matrix} \sigma_y^2 = \underbrace{K^2\sigma_d^2 &#43; \sigma_q^2} \qquad \\offset \end{matrix} \begin{matrix}&#43;\underbrace{K}(\mu_y-\mu_{y\cdot dark})\\slope \qquad \quad \qquad\end{matrix} \qquad(4) $$ 这个方程是传感器特性表征的核心，根据噪声方差$\sigma_y^2$ 与光诱导数字信号均值$\mu_y - \mu_{y\cdot dark}$ 之间的线性关系，可以由斜率确定整体系统增益$K$，并从偏移量确定暗噪声方差$\sigma_d^2$ ，这种方法被称为光子转移方法（Photon Transfer Method）。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-11T10:54:33+00:00">
    <meta property="article:modified_time" content="2025-06-11T10:54:33+00:00">
    <meta property="article:tag" content="Noise">
    <meta property="article:tag" content="Calibration">
    <meta property="article:tag" content="Camera">
    <meta property="article:tag" content="Computational">
    <meta property="article:tag" content="Photography">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="相机噪声标定">
<meta name="twitter:description" content="相机噪声标定流程
第一部分：EMVA1288 相机的线性模型及噪声
像素曝光与相机的线性信号模型
首先，我们需要了解噪声生成的整个过程，并尝试建立一个物理噪声模型，以便进行噪声标定。下图（来自EMVA1288）给我们展示了一个相机的通用物理模型。

所谓的EMVA1288标准，是欧洲机器视觉委员会专门编写的关于数字图像传感器以及相机特性的量化评估标准。该标准历史悠久，我们现在采用的是最新的4.0版本，4.0版本分为了线性版和非线性版，其中线性版本就是针对我们日常使用的数码相机、手机、单反这样常规的相机数字图像传感器，而非线性版本则是指那些不符合线性曝光过程的相机。所以本文所指的EMVA1288主要是针对线性版来展开讲解。
从EMVA1288中我们知道，在整个相机电子系统中，由光照累积的电荷单位被转换为电压，经过放大，最终通过模数转换器（ADC）转换为数字信号$y$。而这整个过程可以看作是线性的，并且可以用具体的量来描述，如系统增益$K$（单位为$DN/e^{-}$，这里$DN$为Digital Number的缩写）等等。所以关于上图中的数字量$\mu_y$（平均像素值）可以建立如下公式：

$$
\mu_y = K(\mu_e &#43; \mu_d) \quad or \quad \mu_y = \mu_{y \cdot dark} &#43; K\mu_e  \qquad (1)
$$
而平均光子数$\mu_p=\frac{AEt_{exp}}{h\nu}=\frac{AEt_{exp}}{hc/\lambda}$，其中$A$为传感器面积，$E$是传感器表面在曝光时间$t_{exp}$ 内的光照度，单位为$W/m^2$，而平均电子数$\mu_e=\eta \mu_p$​，因此上述方程(1)可以转换为以下方程：

$$
\mu_y = \mu_{y\cdot dark} &#43; K\eta \mu_p = \mu_{y\cdot dark} &#43; K\eta\frac{\lambda A}{hc}Et_{exp}  \qquad (2)
$$噪声模型
散粒噪声（Shot noise）是泊松分布的，因此有$\sigma_{e}^2=\mu_e$；根据上图噪声生成模型所示，所有与传感器读出和放大电路相关的噪声源都可以用一个方差为 $\sigma_d^2$ 的与信号无关的正态分布噪声源来描述。最终的模数转换会在量化区间之间添加另一个均匀分布的噪声源，其方差为 $\sigma_q^2=1/12DN^2$。由于所有噪声源的方差线性相加，根据误差的传播规则，数字信号$y$ 的总时域方差(temporal variance)$\sigma_y^2$ 可以表示为：

$$
\sigma_y^2 = K^2(\sigma_d^2 &#43; \sigma_e^2) &#43; \sigma_q^2 \qquad (3)
$$
噪声可以与测量的平均数字信号相关联（利用公式(1)以及$\sigma_{e}^2=\mu_e$​）：

$$
\begin{matrix} \sigma_y^2 = \underbrace{K^2\sigma_d^2 &#43; \sigma_q^2} \qquad \\offset    \end{matrix}
\begin{matrix}&#43;\underbrace{K}(\mu_y-\mu_{y\cdot dark})\\slope \qquad \quad \qquad\end{matrix}  \qquad(4)
$$
这个方程是传感器特性表征的核心，根据噪声方差$\sigma_y^2$ 与光诱导数字信号均值$\mu_y - \mu_{y\cdot dark}$ 之间的线性关系，可以由斜率确定整体系统增益$K$，并从偏移量确定暗噪声方差$\sigma_d^2$ ，这种方法被称为光子转移方法（Photon Transfer Method）。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zli1024.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "相机噪声标定",
      "item": "https://zli1024.github.io/posts/%E7%9B%B8%E6%9C%BA%E5%99%AA%E5%A3%B0%E6%A0%87%E5%AE%9A/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "相机噪声标定",
  "name": "相机噪声标定",
  "description": "相机噪声标定流程 第一部分：EMVA1288 相机的线性模型及噪声 像素曝光与相机的线性信号模型 首先，我们需要了解噪声生成的整个过程，并尝试建立一个物理噪声模型，以便进行噪声标定。下图（来自EMVA1288）给我们展示了一个相机的通用物理模型。\n所谓的EMVA1288标准，是欧洲机器视觉委员会专门编写的关于数字图像传感器以及相机特性的量化评估标准。该标准历史悠久，我们现在采用的是最新的4.0版本，4.0版本分为了线性版和非线性版，其中线性版本就是针对我们日常使用的数码相机、手机、单反这样常规的相机数字图像传感器，而非线性版本则是指那些不符合线性曝光过程的相机。所以本文所指的EMVA1288主要是针对线性版来展开讲解。\n从EMVA1288中我们知道，在整个相机电子系统中，由光照累积的电荷单位被转换为电压，经过放大，最终通过模数转换器（ADC）转换为数字信号$y$。而这整个过程可以看作是线性的，并且可以用具体的量来描述，如系统增益$K$（单位为$DN/e^{-}$，这里$DN$为Digital Number的缩写）等等。所以关于上图中的数字量$\\mu_y$（平均像素值）可以建立如下公式： $$ \\mu_y = K(\\mu_e + \\mu_d) \\quad or \\quad \\mu_y = \\mu_{y \\cdot dark} + K\\mu_e \\qquad (1) $$ 而平均光子数$\\mu_p=\\frac{AEt_{exp}}{h\\nu}=\\frac{AEt_{exp}}{hc/\\lambda}$，其中$A$为传感器面积，$E$是传感器表面在曝光时间$t_{exp}$ 内的光照度，单位为$W/m^2$，而平均电子数$\\mu_e=\\eta \\mu_p$​，因此上述方程(1)可以转换为以下方程： $$ \\mu_y = \\mu_{y\\cdot dark} + K\\eta \\mu_p = \\mu_{y\\cdot dark} + K\\eta\\frac{\\lambda A}{hc}Et_{exp} \\qquad (2) $$噪声模型 散粒噪声（Shot noise）是泊松分布的，因此有$\\sigma_{e}^2=\\mu_e$；根据上图噪声生成模型所示，所有与传感器读出和放大电路相关的噪声源都可以用一个方差为 $\\sigma_d^2$ 的与信号无关的正态分布噪声源来描述。最终的模数转换会在量化区间之间添加另一个均匀分布的噪声源，其方差为 $\\sigma_q^2=1/12DN^2$。由于所有噪声源的方差线性相加，根据误差的传播规则，数字信号$y$ 的总时域方差(temporal variance)$\\sigma_y^2$ 可以表示为： $$ \\sigma_y^2 = K^2(\\sigma_d^2 + \\sigma_e^2) + \\sigma_q^2 \\qquad (3) $$ 噪声可以与测量的平均数字信号相关联（利用公式(1)以及$\\sigma_{e}^2=\\mu_e$​）： $$ \\begin{matrix} \\sigma_y^2 = \\underbrace{K^2\\sigma_d^2 + \\sigma_q^2} \\qquad \\\\offset \\end{matrix} \\begin{matrix}+\\underbrace{K}(\\mu_y-\\mu_{y\\cdot dark})\\\\slope \\qquad \\quad \\qquad\\end{matrix} \\qquad(4) $$ 这个方程是传感器特性表征的核心，根据噪声方差$\\sigma_y^2$ 与光诱导数字信号均值$\\mu_y - \\mu_{y\\cdot dark}$ 之间的线性关系，可以由斜率确定整体系统增益$K$，并从偏移量确定暗噪声方差$\\sigma_d^2$ ，这种方法被称为光子转移方法（Photon Transfer Method）。\n",
  "keywords": [
    "Noise", "Calibration", "Camera", "Computational", "Photography"
  ],
  "articleBody": "相机噪声标定流程 第一部分：EMVA1288 相机的线性模型及噪声 像素曝光与相机的线性信号模型 首先，我们需要了解噪声生成的整个过程，并尝试建立一个物理噪声模型，以便进行噪声标定。下图（来自EMVA1288）给我们展示了一个相机的通用物理模型。\n所谓的EMVA1288标准，是欧洲机器视觉委员会专门编写的关于数字图像传感器以及相机特性的量化评估标准。该标准历史悠久，我们现在采用的是最新的4.0版本，4.0版本分为了线性版和非线性版，其中线性版本就是针对我们日常使用的数码相机、手机、单反这样常规的相机数字图像传感器，而非线性版本则是指那些不符合线性曝光过程的相机。所以本文所指的EMVA1288主要是针对线性版来展开讲解。\n从EMVA1288中我们知道，在整个相机电子系统中，由光照累积的电荷单位被转换为电压，经过放大，最终通过模数转换器（ADC）转换为数字信号$y$。而这整个过程可以看作是线性的，并且可以用具体的量来描述，如系统增益$K$（单位为$DN/e^{-}$，这里$DN$为Digital Number的缩写）等等。所以关于上图中的数字量$\\mu_y$（平均像素值）可以建立如下公式： $$ \\mu_y = K(\\mu_e + \\mu_d) \\quad or \\quad \\mu_y = \\mu_{y \\cdot dark} + K\\mu_e \\qquad (1) $$ 而平均光子数$\\mu_p=\\frac{AEt_{exp}}{h\\nu}=\\frac{AEt_{exp}}{hc/\\lambda}$，其中$A$为传感器面积，$E$是传感器表面在曝光时间$t_{exp}$ 内的光照度，单位为$W/m^2$，而平均电子数$\\mu_e=\\eta \\mu_p$​，因此上述方程(1)可以转换为以下方程： $$ \\mu_y = \\mu_{y\\cdot dark} + K\\eta \\mu_p = \\mu_{y\\cdot dark} + K\\eta\\frac{\\lambda A}{hc}Et_{exp} \\qquad (2) $$噪声模型 散粒噪声（Shot noise）是泊松分布的，因此有$\\sigma_{e}^2=\\mu_e$；根据上图噪声生成模型所示，所有与传感器读出和放大电路相关的噪声源都可以用一个方差为 $\\sigma_d^2$ 的与信号无关的正态分布噪声源来描述。最终的模数转换会在量化区间之间添加另一个均匀分布的噪声源，其方差为 $\\sigma_q^2=1/12DN^2$。由于所有噪声源的方差线性相加，根据误差的传播规则，数字信号$y$ 的总时域方差(temporal variance)$\\sigma_y^2$ 可以表示为： $$ \\sigma_y^2 = K^2(\\sigma_d^2 + \\sigma_e^2) + \\sigma_q^2 \\qquad (3) $$ 噪声可以与测量的平均数字信号相关联（利用公式(1)以及$\\sigma_{e}^2=\\mu_e$​）： $$ \\begin{matrix} \\sigma_y^2 = \\underbrace{K^2\\sigma_d^2 + \\sigma_q^2} \\qquad \\\\offset \\end{matrix} \\begin{matrix}+\\underbrace{K}(\\mu_y-\\mu_{y\\cdot dark})\\\\slope \\qquad \\quad \\qquad\\end{matrix} \\qquad(4) $$ 这个方程是传感器特性表征的核心，根据噪声方差$\\sigma_y^2$ 与光诱导数字信号均值$\\mu_y - \\mu_{y\\cdot dark}$ 之间的线性关系，可以由斜率确定整体系统增益$K$，并从偏移量确定暗噪声方差$\\sigma_d^2$ ，这种方法被称为光子转移方法（Photon Transfer Method）。\n数字信号均值和方差的计算 通过光子转移曲线（公式(4)）我们知道，要想求出整体系统增益（也就是斜率），我们需要得到一组关于数字信号的方差$\\sigma_y ^2$以及均值$\\mu_y-\\mu_{y\\cdot dark}$，以下讲解如何求出这些量：\n一、像素的均值\n首先我们需要计算像素的均值，在实际操作时我们可以这样：在每一个特定的曝光时间下，用相同的相机设置拍摄正对着相机的一个均匀图卡两次，如下图所示，而总共需要在多种曝光时间下进行：\n接下来，我们就可以求特定曝光时间下，这两幅图像中图卡所在区域的像素均值，首先在每幅图像上求均值，再把两次的均值做平均——注意这里的结果也包含了暗信号导致的像素值。如果我们调整相机拍摄的距离，可以使得整个图卡充满相机的视场，这样如果一幅图像的长宽为$M\\times N$ ，我们就可以充分利用到所有的像素来计算图像均值了。 $$ 在某个曝光时间t_{exp}下求均匀图卡的像素均值 \\\\ \\mu_y[k]=\\frac{1}{NM}\\sum_{m=0}^{M-1}\\sum_{n=0}^{N-1}y[k][m][n],(k=0,1) \\quad and \\quad \\mu_y = \\frac{1}{2}(\\mu_y[0]+\\mu_y[1]) \\qquad(5) $$ 注意这里是在一个特定曝光时间下进行的，我们可以在多个曝光时间下重复上述步骤，这样可以得到多个图像（有些文献称为flat-field frame）均值。\n现在我们遮住相机的镜头，此时没有光线进入相机。我们重复上述步骤就可以测出在多个曝光时间下的暗信号（有些文献也称为bias frame）的均值： $$ \\mu_{y\\cdot dark}[k]=\\frac{1}{NM}\\sum_{m=0}^{M-1}\\sum_{n=0}^{N-1}y_{dark}[k][m][n],(k=0,1) \\quad and \\quad \\mu_{y\\cdot dark} = \\frac{1}{2}(\\mu_{y\\cdot dark}[0]+\\mu_{y\\cdot dark}[1]) \\quad(5d) $$ 通过上面两步，我们得到了公式(4)中的$\\mu_y$ 和$\\mu_{y\\cdot dark}$\n二、信号时域噪声的方差\n当我们要求一个随机变量的均值和方差时，通常需要在时域上得到很多个这个变量的值才行。我们在前面之所以在空域上求像素的均值，是基于这样的假设：图像传感器上的每个像素之间的分布是相同的，所以我们用空域上的多个像素值代替了时域上变化的像素值（时域上我们对同一个曝光时间只拍了两幅图像，理论上同一个像素只有两个样本）。为了求得像素值在时域上的变化方差，我们可以基于同样的思想来做。那么似乎按照下面的公式来求就可以完成： $$ \\sigma_y^2=|y-\\mu_y|^2 \\approx \\frac{1}{NM} \\sum_{m=0}^{M-1}\\sum_{n=0}^{N-1}(y[m][n]-\\mu_y)^2 $$ 不过，除了现在描述的这种像素之间的一致性的随机分布，一般在传感器上还会有一种固定的空间噪声，它体现了传感器像素阵列的空间非均匀性。比如在https://homes.psd.uchicago.edu/~ejmartin/pix/20d/tests/noise/index.html#patternnoise中展示的Canon 20D的传感器的空间非均匀性，我们肉眼很容易看出这里的横向条纹，这就是这种非均匀性。所以我们在计算像素值的时域方差时，要特别小心这一点，在这种情况下，整个图像的方差由两部分构成，一个是像素值自身的波动，一个是像素阵列的空间非均匀性。 $$ \\frac{1}{NM}\\sum_{m=0}^{M-1}\\sum_{n=0}^{N-1}(y[k][m][n]-\\mu[0])^2=\\sigma_y^2 + s_y^2 \\qquad(6) $$ 由于空间非均匀性对一个传感器是固定的，所以当我们拍摄两幅图像后，就可以消去这个变量。我们用这两幅图像的方差的差，来估计单个像素时域方差，所以我们可以得到下面的公式： $$ 在某个曝光时间t_{exp}下求均匀图卡的像素方差 \\\\ \\sigma_y^2 = \\frac{1}{2NM}\\sum_{m=0}^{M-1}\\sum_{n=0}^{N-1}[(y[0][m][n]-\\mu[0])-(y[1][m][n]-\\mu[1])]^2 \\\\ = \\frac{1}{2NM}\\sum_{m=0}^{M-1}\\sum_{n=0}^{N-1}(y[0][m][n]-y[1][m][n])^2 - \\frac{1}{2}(\\mu[0]-\\mu[1])^2 \\qquad (7) $$ 当我们多次改变曝光时间时，我们将得到多个$\\sigma_y^2$ 和$\\mu_y - \\mu_{y\\cdot dark}$ ，因而由公式（4）就容易得到此时的系统增益$K$，以及总的加性噪声了$K^2\\sigma_d^2 + \\sigma_q^2$ 。\n信噪比 关于信噪比的计算公式有很多，而在EMVA1288中信噪比的计算公式如下： $$ SNR=\\frac{E(I)}{\\sigma(I)} = \\frac{\\mu_y-\\mu_{y\\cdot dark}}{\\sigma_y} \\qquad (8) $$ 由于我们已经得到一组像素均值和方差，后续将利用这一公式求出SNR的变化曲线图。\n利用公式（2）和（4），上述公式变形为： $$ SNR(\\mu_p)=\\frac{K\\eta \\mu_p}{\\sqrt{K^2\\sigma_d^2+\\sigma_q^2+K^2\\eta\\mu_p}}=\\frac{\\eta \\mu_p}{\\sqrt{\\sigma_d^2+\\sigma_q^2/K^2+\\eta\\mu_p}} $$ 可以看出，信噪比是以平均光子数为自变量的，同时这里的量化噪声一般来说相对较小，这意味着在计算信噪比的过程中，系统增益$K$​几乎可以忽略不记。那么信噪比可以说只取决于传感器的光量子效率(QE，注意它与波长相关)，以及暗噪声。\n关于空域非一致性，个人认为现今的摄像机传感器制造工艺不断在进步，针对拍摄的暗场图像没有很明显的行间非一致性，列间非一致性或者像素间非一致性，所以这里没有列出其测量方法。具体方法可以参考EMVA1288空域非一致性部分。\n第二部分：测量与评估 我们可以通过光子转移方法得到相机系统增益$K$，在此之前我们需要拍摄一组明场图像(flat-field frame)和暗场图像(bias frame)，以下是我的拍摄参数：\nSetup ISO f/# f Temperature Canon EOS M50 3200 f/5.6 15mm room temperature 设定的不同曝光时间为： 1/4000s, 1/3200s, 1/2500s, 1/2000s, 1/1600s, 1/1250s, 1/1000s, 1/800s, 1/640s, 1/500s, 1/400s, 1/320s, 1/250s, 1/200s, 1/160s, 1/125s, 1/100s, 1/80s, 1/60s, 1/50s, 1/40s, 1/30s, 1/25s, 1/20s, 1/15s, 1/13s, 1/10s, 1/8s, 1/6s, 1/5s, 1/4s, 1/3s, 0.4s, 0.5s, 0.6s, 0.8s\n总结来说，明场图像有36组（每组为在不同曝光时间，其他设置相同下连续拍摄的两张图片），暗场图像也36组（每组为在不同曝光时间，其他设置相同下连续拍摄的两张图片），所有数据都可以在目录’./images/‘中找到。\n系统增益的测量 关键点：$\\sigma_y^2=offset+K(\\mu_y-\\mu_{y\\cdot dark})$\n通过光子转移方法测出的结果如下：\n该图展示了测量的方差 $\\sigma_y^2$ 与平均像素值 $\\mu_y - \\mu_{y\\cdot dark}$ 的关系，以及用于确定系统增益 $K$ 的线性回归曲线。绿色点标记了用于线性回归的0-70%的饱和范围。系统增益 $K$ 的值是通过one-sigma原则的统计不确定性（以百分比表示）得到的。\n计算代码包含在 python 文件 “noise_calibration.py” 中，对应生成上述图表的代码片段如下所示：\n拟合结果：\n斜率：$K = 7.58621139$ 截距：840.16712447\n线性范围：0~69.44%（0-70%）符合EMVA1288关于 0-70%饱和范围的标准\n信噪比的测量 关键：$SNR=\\frac{\\mu_y-\\mu_{y\\cdot dark}}{\\sigma_y}$\n计算代码包含在 python 文件 “noise_calibration.py” 中，对应的代码片段如下所示：\n在特定温度下暗电流的评估 代码实现原理在\"Expo.py\" 和 “ISO.py\"这两个文件中，实现的结果如下：\n第三部分：ELD噪声模型 原论文：Physics-Based Noise Modeling for Extreme Low-Light Photography\n该论文提出了一个与EMVA1288稍微有点区别的物理噪声模型，具体分析来说：\n1）将读出噪声分为了暗电流噪声$N_d$ 、源随器噪声$N_s$ 以及热噪声$N_t$ ；\n而EMVA1288在读出噪声上仅考虑的是暗信号的噪声：其中暗信号对应的是暗电荷，它并不是一个固定的值，而是一个与曝光时间和温度都相关的电荷值。具体来说它由两部分组成，其单位是电荷/像素，即每像素平均的暗电荷值。 $$ 暗电荷由两部分组成 \\\\ \\mu_d=\\mu_{d\\cdot 0} +\\mu_{therm}=\\mu_{d\\cdot 0} + \\mu_{I\\cdot y}t_{exp} \\qquad (9) $$ 这里第一部分是一个与曝光时间无关的部分，主要是各种电子电路引起的噪声，而$\\mu_{d\\cdot0}$是它的平均值。\n而第二部分是一个与曝光时间直接相关的量，同时也是与温度相关，这一部分可以被称为热电荷，其中$\\mu_{I\\cdot y}$是所谓的热电流，它的单位是$e^-/(pixel \\cdot s)$ ，即电荷/像素秒。\n2）空域非一致性主要考虑的是行间非一致性；\n3）**将读出噪声和行噪声放到系统增益之后；**关于这一点我有点疑惑，因为读出噪声和行噪声是在电子转换为电压这一阶段的，这在原论文也有提到，但是在公式中却没有体现出读出噪声和行噪声被系统增益$K$ 放大的影响。其实更准确地来说，根据High-level numerical simulations of noise in CCD and CMOS photosensors: review and tutorial论文中的说法，$N_d$和$N_t$ 是在增益放大前（这两噪声是在Electrons阶段），而$N_s$ 是在增益放大后（在Voltage阶段），所以应该分开来讨论。不过原论文作者可能为了简化分析，就可能没分开来讨论各自的影响了。\n总而言之，ELD的总体噪声模型可以用以下公式来表示： $$ N=KN_p+N_{read}+N_r+N_q \\qquad(10) $$a)光子散粒噪声$N_p$​ 光子散粒噪声$N_p$服从的分布：$(I+N_p) \\sim \\mathcal{P}(I)$\n当得出$K$之后，就可以将原始数字信号$D$转换为光电子数$I$ : 可通过$\\mu_y - \\mu_{y\\cdot dark} = K \\mu_e$计算出$\\mu_e$；\n这里将原论文中的公式和EMVA1288作对比以直观地展示各变量的含义：\nELD：$Var(D) = K^2I+Var(N_o)=K(KI)+Var(N_o)$\nEMVA1288：$\\sigma_y^2 = K^2\\sigma_d^2+\\sigma_q^2 + K(\\mu_y - \\mu_{y\\cdot dark})$​\n所以这里可以很清楚地看出$KI=\\mu_y-\\mu_{y\\cdot dark}$\n然后对其施加泊松分布：因为光电子数服从泊松分布，其各个曝光时间的均值已知，所以可以计算出其PMF；\n具体来说，因为在每一特定曝光时间下的均值$I=\\frac{\\mu_y-\\mu_{y\\cdot dark}}{K}$ 可以确定，也就是泊松分布的$\\lambda$ 也已确定，所以可以轻易计算出PMF，下图为四个特定曝光时间下的例子：\n最后将其还原回$D$，进而模拟了真实的光子散粒噪声：其实就是直接利用了$K \\mu_e = \\mu_y - \\mu_{y\\cdot dark}$ ，这样就表示了在未加噪声前的数字信号$D'=K\\mu_e$ 而$D = D' + N$，这里的$N = KN_p+N_{read} + N_r + N_q$\n具体实现代码：\n在文件noise_calibration.py中，实现代码片段如下：\nb)颜色偏差$\\mu_c$ 由于相机成像过程（或者说CMOS传感器中黑电平的存在），全黑状态下拍摄的暗场图中像素值的平均值并不为零，而是应该处于传感器黑电平的位置，而ELD论文提出传感器中直流电噪声会导致一部分的颜色偏差，也就是说直流电噪声会使得像素值均值在黑电平上下波动，因此做了如下测量和评估：\n对于给定一张暗场图像，可以求各个颜色通道的平均值来算出每个通道与其黑电平的偏差。下图所示为在36张暗场图像中统计出的颜色偏差（所用设备为佳能M50）：\n与原论文进行对比：\n可以发现佳能M50的偏差不大，所以应该可以推测出随着现如今制造工艺的进步，这方面的误差应该也会越来越小了。\n关于如何得到黑电平：可以通过dcraw来获取\ndcraw是一个非常有名的软件，专门用于解析RAW格式的图像，在它的官网上列出了大量利用了dcraw进行核心解析代码的软件，可以点击去查看下。在Ubuntu上，只需要在终端输入sudo apt-get install dcraw就可以安装该软件了。（不过需要注意的是dcraw不支持.CR3格式，对此我用的是exiftool工具包）\n示例：\nexport input_file=”./images/_MG_0771.CR2\"\ndcraw -4 -d -v -T $input_file\n通过以上两个命令就可以得到关于黑电平和其他信息\n佳能M50各通道黑电平：2048 2048 2048 2048\n具体实现代码：\n在文件color_bias.py中，实现代码片段如下：\nc)行噪声$N_{r}$ 原论文说是直接对bias frames进行离散傅里叶变换，这里我对曝光时间最小（Expo = 1/4000s）的bias frame进行DFT，用的np.fft，同时对明显的行噪声和列噪声（来源：网上找的例子）进行对比\nnp.fft.fftshift的作用：通过将零频分量移动到数组中心，重新排列傅里叶变换的结果\n我们知道：经过FFT之后，输出的频率范围是[0,fs]，但是，我们研究的范围一般是[-fs/2, fs/2]，也就是零频在中间，因此就需要将FFT的结果通过fftshift处理一下，将零频分量移到序列中间。\nBias frame(1/4000s):\n这么一对比，Canon M50拍出来的bias frames行噪声就不是很明显。\n具体实现代码：\n在文件row_noise.py中，实现代码片段如下：\n在接下去之前，论文第六页在Estimate $\\mu_c$​ for color bias 结尾处提到为了消除直流噪声对后续其他噪声参数估计的影响，先从暗场图像中减去每个颜色通道的平均值，这里我每个通道减去的值都取为2048\n行噪声服从均值为零的高斯分布：$N_r \\sim \\mathcal{N}(o, \\sigma_r)$\n关于参数$\\sigma_r$ 是如何估计的：首先求出暗场图像每行的均值（这里论文的意思好像不需要减去黑电平也能求出$\\sigma_r$），然后相应地就可以得到每一行的方差，最后行噪声就是由这么一组按行排列的高斯分布采样得到的信号值。关于这部分的实现原理去read_noise.py看代码实现会更清楚直观一些。\n######### Row noise parameters ######### # extract mean values from each row mu_row = np.sum(raw_data, axis=1) / w mu_row2d = mu_row.reshape(h, 1) mu_row_t = np.tile(mu_row2d, w) # maximizing the log-likelihood sigma2 = np.sum((raw_data - mu_row_t)**2, axis=1) / w ######################## Step 2: row noise image ###################### raw_row = np.zeros((h, w), dtype=np.float64) for i in range(h): raw_row[i][:] = np.random.normal(loc=mu_row[i], scale=np.sqrt(sigma2[i]), size=w) c) 读噪声$N_{read}$ 补充下关于Probability Plot的知识：\nThe probability plot is a way of visually comparing the data coming from different distributions. These data can be of empirical dataset or theoretical dataset. The probability plot can be of two types:\nP-P plot: The (Probability-to-Probability) p-p plot is the way to visualize the comparing of cumulative distribution function (CDFs) of the two distributions (empirical and theoretical) against each other. Q-Q plot: The q-q (Quantile-to-Quantile) plot is used to compare the quantiles of two distributions. The quantiles can be defined as continuous intervals with equal probabilities or dividing the samples between a similar way The distributions may be theoretical or sample distributions from a process, etc. The normal probability plot is a case of the q-q plot. Normal Probability plot: The normal probability plot is a way of knowing whether the dataset is normally distributed or not. In this plot, data is plotted against the theoretical normal distribution plot in a way such that if a given dataset is normally distributed it should form an approximate straight line. The normal probability plot is a case of the probability plot (more specifically Q-Q plot). This plot is commonly used in the industry for finding the deviation from the normal process.\nSource: https://www.geeksforgeeks.org/normal-probability-plot/\n1. Gaussian Probability Plot\nPreprocess:\n用暗场图像先减去上一步的行噪声，然后为了加速运算，我在代码中取图像正中间一小块部分来运算（不求速度的话可以用整张图的数据去算分布），然后就可以画Q-Q图了。\n结果发现和正态分布拟合地很好，接下来看看和Tukey lambda分布拟合情况如何。\n2. Tukey Lambda PPCC Plot\n补充知识：\n*Reference: *\n1.https://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ppccplot.htm\n2.https://moonapi.com/news/4061.html\n3.https://www.itl.nist.gov/div898/handbook/eda/section3/eda366f.htm\nThe Tukey Lambda PPCC plot, with shape parameter λ, is particularly useful for symmetric distributions. It indicates whether a distribution is short or long tailed and it can further indicate several common distributions. Specifically:\nλ = -1: distribution is approximately Cauchy λ = 0: distribution is exactly logistic λ = 0.14: distribution is approximately normal λ = 0.5: distribution is U-shaped λ = 1: distribution is exactly uniform If the Tukey Lambda PPCC plot gives a maximum value near 0.14, we can reasonably conclude that the normal distribution is a good model for the data. If the maximum value is less than 0.14, a long-tailed distribution such as the double exponential or logistic would be a better choice. If the maximum value is near -1, this implies the selection of very long-tailed distribution, such as the Cauchy. If the maximum value is greater than 0.14, this implies a short-tailed distribution such as the Beta or uniform.\nSource: https://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ppccplot.htm\nPPCC图可以用来求分布最符合的形状参数$\\lambda$ ，结果如上：$\\lambda = 0.164$ 表明了在Canon M50拍下的暗场图像呈短尾分布（$-1 \u003c\\lambda \u003c 0.14$为长尾分布；$\\lambda=0.14$呈完美的正态分布；$\\lambda\u003e0.14$​ 呈短尾分布）\n注意在用Tukey lambda分布估计数据分布时要事先画直方图看数据是否对称分布\nAs the Tukey-Lambda distribution is a symmetric distribution, the use of the Tukey-Lambda PPCC plot to determine a reasonable distribution to model the data only applies to symmetric distributions. A histogram of the data should provide evidence as to whether the data can be reasonably modeled with a symmetric distribution.\n3. Tukey Lambda Probability Plot\n由于在PPCC图中我们得到了关于暗场图像的分布形状参数，也就是shape_param_max，即shape_param_max = $\\lambda = 0.164$ ，所以也就得到了形状参数为0.164的Tukey lambda分布来估计暗场图像的分布，标定完后续就可以用这个分布来建立数据集。\n用形状参数$\\lambda = 0.164$ 的分布来拟合发现和正态分布的Probability Plot拟合程度$R^2$区别不大，所以读出噪声可以近似为正态分布；关于Tukey Lambda分布的拟合情况请看下图（这里Tukey Lambda分布的参数$\\lambda$ 我取的是-0.14，即原论文中佳能EOS70D的参数来进行对比）：\n可以发现佳能M50的读出噪声对Tukey Lambda的分布拟合情况并不好，不如正态分布；不过发现在噪声极少的情况下（曝光时间30s，ISO为200），读出噪声更符合Tukey Lambda的分布，原因可能是当噪声变多后分布符合大数定律的原则。\n具体实现代码：\n在文件read_noise.py中，实现代码片段如下：\nd)重建流程 这一步是为了模拟仿真出真实相机传感器中产生的各种噪声，也就是利用公式（10）复原上述所讲的各种噪声，然后进行ISP流程如：线性化–\u003e白平衡–\u003e去马赛克–\u003e颜色矫正–\u003e亮度拉伸/Gamma矫正，最后重建出一张噪声图。\n首先通过直方图直观地看重建的噪声图和原暗场图像之间的差异：\n图形差异挺大的，原因可能是在原暗场图像中存在不少离群点，那我们用数据差异来看二者之间差异多大；这里用的指标是$R^2$ 和KL散度，其中$R^2$ 作了一些处理（由于噪声是随机出现在图像不同像素点位置的，所以为了避免位置对数值上差异的干扰，代码中对两幅图像素值作了排序，这样算$R^2$ 才不会出现负值），结果如下：\nR2 for estimated model: 0.9972249549587314\nKL-divergence: 0.0001303227610267369\n可以看出最后重建的效果不错，噪声图比较接近真实的暗场图像。\n关于为何在代码中为何不加入光子散粒噪声：\n因为这里重建的是暗场图像，不受实际光子影响，所以没加。如果想在一幅真实环境下图像加噪声，此时就可以考虑光子散粒噪声$N_p$的影响了\n最后重建出来的效果如下（色调有点偏白，不过不是重建中出现的问题）：\n**具体实现代码：**在文件noise_img.py中可以直观地看每一步实现的细节\n",
  "wordCount" : "998",
  "inLanguage": "en",
  "datePublished": "2025-06-11T10:54:33Z",
  "dateModified": "2025-06-11T10:54:33Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zli1024.github.io/posts/%E7%9B%B8%E6%9C%BA%E5%99%AA%E5%A3%B0%E6%A0%87%E5%AE%9A/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Zhilin's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zli1024.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zli1024.github.io/" accesskey="h" title="Zhilin&#39;s Blog (Alt + H)">Zhilin&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zli1024.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://zli1024.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://zli1024.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://zli1024.github.io/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://zli1024.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://zli1024.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      相机噪声标定
    </h1>
    <div class="post-meta"><span title='2025-06-11 10:54:33 +0000 UTC'>June 11, 2025</span>&nbsp;·&nbsp;5 min

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e7%9b%b8%e6%9c%ba%e5%99%aa%e5%a3%b0%e6%a0%87%e5%ae%9a%e6%b5%81%e7%a8%8b" aria-label="相机噪声标定流程">相机噪声标定流程</a><ul>
                            
                    <li>
                        <a href="#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86emva1288-%e7%9b%b8%e6%9c%ba%e7%9a%84%e7%ba%bf%e6%80%a7%e6%a8%a1%e5%9e%8b%e5%8f%8a%e5%99%aa%e5%a3%b0" aria-label="第一部分：EMVA1288 相机的线性模型及噪声">第一部分：EMVA1288 相机的线性模型及噪声</a><ul>
                            
                    <li>
                        <a href="#%e5%83%8f%e7%b4%a0%e6%9b%9d%e5%85%89%e4%b8%8e%e7%9b%b8%e6%9c%ba%e7%9a%84%e7%ba%bf%e6%80%a7%e4%bf%a1%e5%8f%b7%e6%a8%a1%e5%9e%8b" aria-label="像素曝光与相机的线性信号模型">像素曝光与相机的线性信号模型</a></li>
                    <li>
                        <a href="#%e5%99%aa%e5%a3%b0%e6%a8%a1%e5%9e%8b" aria-label="噪声模型">噪声模型</a></li>
                    <li>
                        <a href="#%e6%95%b0%e5%ad%97%e4%bf%a1%e5%8f%b7%e5%9d%87%e5%80%bc%e5%92%8c%e6%96%b9%e5%b7%ae%e7%9a%84%e8%ae%a1%e7%ae%97" aria-label="数字信号均值和方差的计算">数字信号均值和方差的计算</a></li>
                    <li>
                        <a href="#%e4%bf%a1%e5%99%aa%e6%af%94" aria-label="信噪比">信噪比</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86%e6%b5%8b%e9%87%8f%e4%b8%8e%e8%af%84%e4%bc%b0" aria-label="第二部分：测量与评估">第二部分：测量与评估</a><ul>
                            
                    <li>
                        <a href="#%e7%b3%bb%e7%bb%9f%e5%a2%9e%e7%9b%8a%e7%9a%84%e6%b5%8b%e9%87%8f" aria-label="系统增益的测量">系统增益的测量</a></li>
                    <li>
                        <a href="#%e4%bf%a1%e5%99%aa%e6%af%94%e7%9a%84%e6%b5%8b%e9%87%8f" aria-label="信噪比的测量">信噪比的测量</a></li>
                    <li>
                        <a href="#%e5%9c%a8%e7%89%b9%e5%ae%9a%e6%b8%a9%e5%ba%a6%e4%b8%8b%e6%9a%97%e7%94%b5%e6%b5%81%e7%9a%84%e8%af%84%e4%bc%b0" aria-label="在特定温度下暗电流的评估">在特定温度下暗电流的评估</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%ac%ac%e4%b8%89%e9%83%a8%e5%88%86eld%e5%99%aa%e5%a3%b0%e6%a8%a1%e5%9e%8b" aria-label="第三部分：ELD噪声模型">第三部分：ELD噪声模型</a><ul>
                            
                    <li>
                        <a href="#a%e5%85%89%e5%ad%90%e6%95%a3%e7%b2%92%e5%99%aa%e5%a3%b0" aria-label="a)光子散粒噪声$N_p$​">a)光子散粒噪声$N_p$​</a></li>
                    <li>
                        <a href="#b%e9%a2%9c%e8%89%b2%e5%81%8f%e5%b7%ae" aria-label="b)颜色偏差$\mu_c$">b)颜色偏差$\mu_c$</a></li>
                    <li>
                        <a href="#c%e8%a1%8c%e5%99%aa%e5%a3%b0" aria-label="c)行噪声$N_{r}$">c)行噪声$N_{r}$</a></li>
                    <li>
                        <a href="#c-%e8%af%bb%e5%99%aa%e5%a3%b0" aria-label="c) 读噪声$N_{read}$">c) 读噪声$N_{read}$</a></li>
                    <li>
                        <a href="#d%e9%87%8d%e5%bb%ba%e6%b5%81%e7%a8%8b" aria-label="d)重建流程">d)重建流程</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    
    document.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();
    
        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        if (elements.length > 0) {
            
            activeElement = elements[0];
            const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
            document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
        }
    
        
        const topLink = document.getElementById('top-link');
        if (topLink) {
            topLink.addEventListener('click', (event) => {
                
                event.preventDefault();
    
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        }
    }, false);
    
    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);
    
    window.addEventListener('scroll', () => {
        
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
    
        
        if (scrollPosition === 0) {
            return;
        }
    
        
        if (elements && elements.length > 0) {
            
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - scrollPosition) > 0 && 
                    (getOffsetTop(element) - scrollPosition) < window.innerHeight / 2) {
                    return element;
                }
            }) || activeElement;
    
            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                const tocLink = document.querySelector(`.inner ul li a[href="#${id}"]`);
                if (element === activeElement){
                    tocLink.classList.add('active');
    
                    
                    const tocContainer = document.querySelector('.toc .inner');
                    const linkOffsetTop = tocLink.offsetTop;
                    const containerHeight = tocContainer.clientHeight;
                    const linkHeight = tocLink.clientHeight;
    
                    
                    const scrollPosition = linkOffsetTop - (containerHeight / 2) + (linkHeight / 2);
                    tocContainer.scrollTo({ top: scrollPosition, behavior: 'smooth' });
                } else {
                    tocLink.classList.remove('active');
                }
            });
        }
    }, false);
    
    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);
    
    function checkTocPosition() {
        const width = document.body.scrollWidth;
    
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }
    
    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
    
</script>

  <div class="post-content"><h1 id="相机噪声标定流程">相机噪声标定流程<a hidden class="anchor" aria-hidden="true" href="#相机噪声标定流程">#</a></h1>
<h2 id="第一部分emva1288-相机的线性模型及噪声">第一部分：EMVA1288 相机的线性模型及噪声<a hidden class="anchor" aria-hidden="true" href="#第一部分emva1288-相机的线性模型及噪声">#</a></h2>
<h3 id="像素曝光与相机的线性信号模型">像素曝光与相机的线性信号模型<a hidden class="anchor" aria-hidden="true" href="#像素曝光与相机的线性信号模型">#</a></h3>
<p>首先，我们需要了解噪声生成的整个过程，并尝试建立一个物理噪声模型，以便进行噪声标定。下图（来自EMVA1288）给我们展示了一个相机的通用物理模型。</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506112302533.png"></p>
<p>所谓的EMVA1288标准，是欧洲机器视觉委员会专门编写的关于数字图像传感器以及相机特性的量化评估标准。该标准历史悠久，我们现在采用的是最新的4.0版本，4.0版本分为了线性版和非线性版，其中线性版本就是针对我们日常使用的数码相机、手机、单反这样常规的相机数字图像传感器，而非线性版本则是指那些不符合线性曝光过程的相机。所以本文所指的EMVA1288主要是针对线性版来展开讲解。</p>
<p>从EMVA1288中我们知道，在整个相机电子系统中，由光照累积的电荷单位被转换为电压，经过放大，最终通过模数转换器（ADC）转换为数字信号$y$。而这整个过程可以看作是线性的，并且可以用具体的量来描述，如系统增益$K$（单位为$DN/e^{-}$，这里$DN$为Digital Number的缩写）等等。所以关于上图中的数字量$\mu_y$（平均像素值）可以建立如下公式：
</p>
$$
\mu_y = K(\mu_e + \mu_d) \quad or \quad \mu_y = \mu_{y \cdot dark} + K\mu_e  \qquad (1)
$$<p>
而平均光子数$\mu_p=\frac{AEt_{exp}}{h\nu}=\frac{AEt_{exp}}{hc/\lambda}$，其中$A$为传感器面积，$E$是传感器表面在曝光时间$t_{exp}$ 内的光照度，单位为$W/m^2$，而平均电子数$\mu_e=\eta \mu_p$​，因此上述方程(1)可以转换为以下方程：
</p>
$$
\mu_y = \mu_{y\cdot dark} + K\eta \mu_p = \mu_{y\cdot dark} + K\eta\frac{\lambda A}{hc}Et_{exp}  \qquad (2)
$$<h3 id="噪声模型">噪声模型<a hidden class="anchor" aria-hidden="true" href="#噪声模型">#</a></h3>
<p>散粒噪声（Shot noise）是<strong>泊松分布</strong>的，因此有$\sigma_{e}^2=\mu_e$；根据上图噪声生成模型所示，所有与传感器读出和放大电路相关的噪声源都可以用一个方差为 $\sigma_d^2$ 的与信号无关的<strong>正态分布</strong>噪声源来描述。最终的模数转换会在量化区间之间添加另一个<strong>均匀分布</strong>的噪声源，其方差为 $\sigma_q^2=1/12DN^2$。由于所有噪声源的方差线性相加，根据误差的传播规则，数字信号$y$ 的总时域方差(temporal variance)$\sigma_y^2$ 可以表示为：
</p>
$$
\sigma_y^2 = K^2(\sigma_d^2 + \sigma_e^2) + \sigma_q^2 \qquad (3)
$$<p>
噪声可以与测量的平均数字信号相关联（利用公式(1)以及$\sigma_{e}^2=\mu_e$​）：
</p>
$$
\begin{matrix} \sigma_y^2 = \underbrace{K^2\sigma_d^2 + \sigma_q^2} \qquad \\offset    \end{matrix}
\begin{matrix}+\underbrace{K}(\mu_y-\mu_{y\cdot dark})\\slope \qquad \quad \qquad\end{matrix}  \qquad(4)
$$<p>
<strong>这个方程是传感器特性表征的核心，根据噪声方差$\sigma_y^2$ 与光诱导数字信号均值$\mu_y - \mu_{y\cdot dark}$ 之间的线性关系，可以由斜率确定整体系统增益$K$，并从偏移量确定暗噪声方差$\sigma_d^2$ ，这种方法被称为光子转移方法（Photon Transfer Method）。</strong></p>
<h3 id="数字信号均值和方差的计算">数字信号均值和方差的计算<a hidden class="anchor" aria-hidden="true" href="#数字信号均值和方差的计算">#</a></h3>
<p>通过光子转移曲线（公式(4)）我们知道，要想求出整体系统增益（也就是斜率），我们需要得到一组关于数字信号的方差$\sigma_y ^2$以及均值$\mu_y-\mu_{y\cdot dark}$，以下讲解如何求出这些量：</p>
<p>一、像素的均值</p>
<p>首先我们需要计算像素的均值，在实际操作时我们可以这样：在每一个特定的曝光时间下，用相同的相机设置拍摄正对着相机的一个均匀图卡两次，如下图所示，而总共需要在多种曝光时间下进行：</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506112303371.png"></p>
<p>接下来，我们就可以求特定曝光时间下，这两幅图像中图卡所在区域的像素均值，首先在每幅图像上求均值，再把两次的均值做平均——注意这里的结果也包含了暗信号导致的像素值。如果我们调整相机拍摄的距离，可以使得整个图卡充满相机的视场，这样如果一幅图像的长宽为$M\times N$ ，我们就可以充分利用到所有的像素来计算图像均值了。
</p>
$$
在某个曝光时间t_{exp}下求均匀图卡的像素均值
\\
\mu_y[k]=\frac{1}{NM}\sum_{m=0}^{M-1}\sum_{n=0}^{N-1}y[k][m][n],(k=0,1) \quad and \quad \mu_y = \frac{1}{2}(\mu_y[0]+\mu_y[1]) \qquad(5)
$$<p>
注意这里是在一个特定曝光时间下进行的，我们可以在多个曝光时间下重复上述步骤，这样可以得到多个图像（有些文献称为flat-field frame）均值。</p>
<p>现在我们遮住相机的镜头，此时没有光线进入相机。我们重复上述步骤就可以测出在多个曝光时间下的暗信号（有些文献也称为bias frame）的均值：
</p>
$$
\mu_{y\cdot dark}[k]=\frac{1}{NM}\sum_{m=0}^{M-1}\sum_{n=0}^{N-1}y_{dark}[k][m][n],(k=0,1) \quad and \quad \mu_{y\cdot dark} = \frac{1}{2}(\mu_{y\cdot dark}[0]+\mu_{y\cdot dark}[1]) \quad(5d)
$$<p>
通过上面两步，我们得到了公式(4)中的$\mu_y$ 和$\mu_{y\cdot dark}$</p>
<p>二、信号时域噪声的方差</p>
<p>当我们要求一个随机变量的均值和方差时，通常需要在时域上得到很多个这个变量的值才行。我们在前面之所以在空域上求像素的均值，是基于这样的假设：图像传感器上的每个像素之间的分布是相同的，所以我们用空域上的多个像素值代替了时域上变化的像素值（时域上我们对同一个曝光时间只拍了两幅图像，理论上同一个像素只有两个样本）。为了求得像素值在时域上的变化方差，我们可以基于同样的思想来做。那么似乎按照下面的公式来求就可以完成：
</p>
$$
\sigma_y^2=|y-\mu_y|^2 \approx \frac{1}{NM} \sum_{m=0}^{M-1}\sum_{n=0}^{N-1}(y[m][n]-\mu_y)^2
$$<p>
不过，除了现在描述的这种像素之间的一致性的随机分布，一般在传感器上还会有一种固定的空间噪声，它体现了传感器像素阵列的空间非均匀性。比如在https://homes.psd.uchicago.edu/~ejmartin/pix/20d/tests/noise/index.html#patternnoise中展示的Canon 20D的传感器的空间非均匀性，我们肉眼很容易看出这里的横向条纹，这就是这种非均匀性。所以我们在计算像素值的时域方差时，要特别小心这一点，在这种情况下，整个图像的方差由两部分构成，一个是像素值自身的波动，一个是像素阵列的空间非均匀性。
</p>
$$
\frac{1}{NM}\sum_{m=0}^{M-1}\sum_{n=0}^{N-1}(y[k][m][n]-\mu[0])^2=\sigma_y^2 + s_y^2 \qquad(6)
$$<p>
由于空间非均匀性对一个传感器是固定的，所以当我们拍摄两幅图像后，就可以消去这个变量。我们用这两幅图像的方差的差，来估计单个像素时域方差，所以我们可以得到下面的公式：
</p>
$$
在某个曝光时间t_{exp}下求均匀图卡的像素方差
\\
\sigma_y^2 = \frac{1}{2NM}\sum_{m=0}^{M-1}\sum_{n=0}^{N-1}[(y[0][m][n]-\mu[0])-(y[1][m][n]-\mu[1])]^2 \\
= \frac{1}{2NM}\sum_{m=0}^{M-1}\sum_{n=0}^{N-1}(y[0][m][n]-y[1][m][n])^2 - \frac{1}{2}(\mu[0]-\mu[1])^2 \qquad (7)
$$<p>
当我们多次改变曝光时间时，我们将得到多个$\sigma_y^2$ 和$\mu_y - \mu_{y\cdot dark}$ ，因而由公式（4）就容易得到此时的系统增益$K$，以及总的加性噪声了$K^2\sigma_d^2 + \sigma_q^2$ 。</p>
<h3 id="信噪比">信噪比<a hidden class="anchor" aria-hidden="true" href="#信噪比">#</a></h3>
<p>关于信噪比的计算公式有很多，而在EMVA1288中信噪比的计算公式如下：
</p>
$$
SNR=\frac{E(I)}{\sigma(I)} = \frac{\mu_y-\mu_{y\cdot dark}}{\sigma_y} \qquad (8)
$$<p>
由于我们已经得到一组像素均值和方差，后续将利用这一公式求出SNR的变化曲线图。</p>
<p>利用公式（2）和（4），上述公式变形为：
</p>
$$
SNR(\mu_p)=\frac{K\eta \mu_p}{\sqrt{K^2\sigma_d^2+\sigma_q^2+K^2\eta\mu_p}}=\frac{\eta \mu_p}{\sqrt{\sigma_d^2+\sigma_q^2/K^2+\eta\mu_p}}
$$<p>
可以看出，信噪比是以平均光子数为自变量的，同时这里的量化噪声一般来说相对较小，这意味着在计算信噪比的过程中，系统增益$K$​几乎可以忽略不记。那么信噪比可以说只取决于传感器的光量子效率(QE，注意它与波长相关)，以及暗噪声。</p>
<blockquote>
<p>关于空域非一致性，个人认为现今的摄像机传感器制造工艺不断在进步，针对拍摄的暗场图像没有很明显的行间非一致性，列间非一致性或者像素间非一致性，所以这里没有列出其测量方法。具体方法可以参考EMVA1288空域非一致性部分。</p></blockquote>
<h2 id="第二部分测量与评估">第二部分：测量与评估<a hidden class="anchor" aria-hidden="true" href="#第二部分测量与评估">#</a></h2>
<p>我们可以通过光子转移方法得到相机系统增益$K$，在此之前我们需要拍摄一组明场图像(flat-field frame)和暗场图像(bias frame)，以下是我的拍摄参数：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">Setup</th>
          <th style="text-align: center">ISO</th>
          <th style="text-align: center">f/#</th>
          <th style="text-align: center">f</th>
          <th style="text-align: center">Temperature</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">Canon EOS M50</td>
          <td style="text-align: center">3200</td>
          <td style="text-align: center">f/5.6</td>
          <td style="text-align: center">15mm</td>
          <td style="text-align: center">room temperature</td>
      </tr>
  </tbody>
</table>
<p>设定的不同曝光时间为： 1/4000s, 1/3200s, 1/2500s, 1/2000s, 1/1600s, 1/1250s, 1/1000s, 1/800s, 1/640s, 1/500s, 1/400s, 1/320s, 1/250s, 1/200s, 1/160s, 1/125s, 1/100s, 1/80s, 1/60s, 1/50s, 1/40s, 1/30s, 1/25s, 1/20s, 1/15s, 1/13s, 1/10s, 1/8s, 1/6s, 1/5s, 1/4s, 1/3s, 0.4s, 0.5s, 0.6s, 0.8s</p>
<p>总结来说，明场图像有36组（每组为在不同曝光时间，其他设置相同下连续拍摄的两张图片），暗场图像也36组（每组为在不同曝光时间，其他设置相同下连续拍摄的两张图片），所有数据都可以在目录&rsquo;./images/&lsquo;中找到。</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506112303445.png"></p>
<h3 id="系统增益的测量">系统增益的测量<a hidden class="anchor" aria-hidden="true" href="#系统增益的测量">#</a></h3>
<blockquote>
<p>关键点：$\sigma_y^2=offset+K(\mu_y-\mu_{y\cdot dark})$</p></blockquote>
<p>通过光子转移方法测出的结果如下：</p>
<p><!-- raw HTML omitted -->   <!-- raw HTML omitted --></p>
<p>该图展示了测量的方差 $\sigma_y^2$ 与平均像素值 $\mu_y - \mu_{y\cdot dark}$ 的关系，以及用于确定系统增益 $K$ 的线性回归曲线。绿色点标记了用于线性回归的0-70%的饱和范围。系统增益 $K$ 的值是通过one-sigma原则的统计不确定性（以百分比表示）得到的。</p>
<p>计算代码包含在 python 文件 “noise_calibration.py” 中，对应生成上述图表的代码片段如下所示：</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506112305604.png"><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506112305266.png"></p>
<p>拟合结果：</p>
<p>斜率：$K = 7.58621139$  截距：840.16712447</p>
<p>线性范围：0~69.44%（0-70%）符合EMVA1288关于 0-70%饱和范围的标准</p>
<h3 id="信噪比的测量">信噪比的测量<a hidden class="anchor" aria-hidden="true" href="#信噪比的测量">#</a></h3>
<blockquote>
<p>关键：$SNR=\frac{\mu_y-\mu_{y\cdot dark}}{\sigma_y}$</p></blockquote>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506112305369.png"></p>
<p>计算代码包含在 python 文件 “noise_calibration.py” 中，对应的代码片段如下所示：</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506112305184.png"></p>
<h3 id="在特定温度下暗电流的评估">在特定温度下暗电流的评估<a hidden class="anchor" aria-hidden="true" href="#在特定温度下暗电流的评估">#</a></h3>
<p>代码实现原理在&quot;Expo.py&quot; 和 &ldquo;ISO.py&quot;这两个文件中，实现的结果如下：</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="第三部分eld噪声模型">第三部分：ELD噪声模型<a hidden class="anchor" aria-hidden="true" href="#第三部分eld噪声模型">#</a></h2>
<p>原论文：<a href="https://ieeexplore.ieee.org/abstract/document/9511233">Physics-Based Noise Modeling for Extreme Low-Light Photography</a></p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506112308045.png"></p>
<p>该论文提出了一个与EMVA1288稍微有点区别的物理噪声模型，具体分析来说：</p>
<p>1）<strong>将读出噪声分为了暗电流噪声$N_d$ 、源随器噪声$N_s$ 以及热噪声$N_t$ ；</strong></p>
<p>而EMVA1288在读出噪声上仅考虑的是暗信号的噪声：其中暗信号对应的是暗电荷，它并不是一个固定的值，而是一个与曝光时间和温度都相关的电荷值。具体来说它由两部分组成，其单位是电荷/像素，即每像素平均的暗电荷值。
</p>
$$
暗电荷由两部分组成
\\
\mu_d=\mu_{d\cdot 0} +\mu_{therm}=\mu_{d\cdot 0} + \mu_{I\cdot y}t_{exp} \qquad (9)
$$<p>
这里第一部分是一个与曝光时间无关的部分，主要是各种电子电路引起的噪声，而$\mu_{d\cdot0}$是它的平均值。</p>
<p>而第二部分是一个与曝光时间直接相关的量，同时也是与温度相关，这一部分可以被称为热电荷，其中$\mu_{I\cdot y}$是所谓的热电流，它的单位是$e^-/(pixel \cdot s)$ ，即电荷/像素秒。</p>
<p>2）<strong>空域非一致性主要考虑的是行间非一致性；</strong></p>
<p>3）**将读出噪声和行噪声放到系统增益之后；**关于这一点我有点疑惑，因为读出噪声和行噪声是在电子转换为电压这一阶段的，这在原论文也有提到，但是在公式中却没有体现出读出噪声和行噪声被系统增益$K$ 放大的影响。其实更准确地来说，根据<a href="https://arxiv.org/abs/1412.4031">High-level numerical simulations of noise in CCD and CMOS photosensors: review and tutorial</a>论文中的说法，$N_d$和$N_t$ 是在增益放大前（这两噪声是在Electrons阶段），而$N_s$ 是在增益放大后（在Voltage阶段），所以应该分开来讨论。不过原论文作者可能为了简化分析，就可能没分开来讨论各自的影响了。</p>
<p>总而言之，ELD的总体噪声模型可以用以下公式来表示：
</p>
$$
N=KN_p+N_{read}+N_r+N_q \qquad(10)
$$<h3 id="a光子散粒噪声">a)光子散粒噪声$N_p$​<a hidden class="anchor" aria-hidden="true" href="#a光子散粒噪声">#</a></h3>
<p>光子散粒噪声$N_p$服从的分布：$(I+N_p) \sim \mathcal{P}(I)$</p>
<ol>
<li>
<p>当得出$K$之后，就可以将原始数字信号$D$转换为光电子数$I$ :  可通过$\mu_y - \mu_{y\cdot dark} = K \mu_e$计算出$\mu_e$；</p>
<p>这里将原论文中的公式和EMVA1288作对比以直观地展示各变量的含义：</p>
<p>ELD：$Var(D) = K^2I+Var(N_o)=K(KI)+Var(N_o)$</p>
<p>EMVA1288：$\sigma_y^2 = K^2\sigma_d^2+\sigma_q^2 + K(\mu_y - \mu_{y\cdot dark})$​</p>
<p>所以这里可以很清楚地看出$KI=\mu_y-\mu_{y\cdot dark}$</p>
</li>
<li>
<p>然后对其施加泊松分布：因为光电子数服从泊松分布，其各个曝光时间的均值已知，所以可以计算出其PMF；</p>
<p>具体来说，因为在每一特定曝光时间下的均值$I=\frac{\mu_y-\mu_{y\cdot dark}}{K}$ 可以确定，也就是泊松分布的$\lambda$ 也已确定，所以可以轻易计算出PMF，下图为四个特定曝光时间下的例子：</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
</li>
<li>
<p>最后将其还原回$D$，进而模拟了真实的光子散粒噪声：其实就是直接利用了$K \mu_e = \mu_y - \mu_{y\cdot dark}$ ，这样就表示了在未加噪声前的数字信号$D'=K\mu_e$ 而$D = D' + N$，这里的$N = KN_p+N_{read} + N_r + N_q$</p>
</li>
</ol>
<p><strong>具体实现代码：</strong></p>
<p>在文件noise_calibration.py中，实现代码片段如下：</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506121005798.png"></p>
<h3 id="b颜色偏差">b)颜色偏差$\mu_c$<a hidden class="anchor" aria-hidden="true" href="#b颜色偏差">#</a></h3>
<p>由于相机成像过程（或者说CMOS传感器中黑电平的存在），全黑状态下拍摄的暗场图中像素值的平均值并不为零，而是应该处于传感器黑电平的位置，而ELD论文提出传感器中直流电噪声会导致一部分的颜色偏差，也就是说直流电噪声会使得像素值均值在黑电平上下波动，因此做了如下测量和评估：</p>
<p>对于给定一张暗场图像，可以求各个颜色通道的平均值来算出每个通道与其黑电平的偏差。下图所示为在36张暗场图像中统计出的颜色偏差（所用设备为佳能M50）：</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>与原论文进行对比：</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506121011441.png"></p>
<p>可以发现佳能M50的偏差不大，所以应该可以推测出随着现如今制造工艺的进步，这方面的误差应该也会越来越小了。</p>
<blockquote>
<p>关于如何得到黑电平：可以通过dcraw来获取</p>
<p>dcraw是一个非常有名的软件，专门用于解析RAW格式的图像，在它的官网上列出了大量利用了dcraw进行核心解析代码的软件，可以点击去查看下。在Ubuntu上，只需要在终端输入sudo apt-get install dcraw就可以安装该软件了。（不过需要注意的是dcraw不支持.CR3格式，对此我用的是exiftool工具包）</p>
<p>示例：</p>
<p>export input_file=&rdquo;./images/_MG_0771.CR2&quot;</p>
<p>dcraw -4 -d -v -T $input_file</p>
<p>通过以上两个命令就可以得到关于黑电平和其他信息</p>
<p><strong>佳能M50各通道黑电平：2048 2048 2048 2048</strong></p></blockquote>
<p><strong>具体实现代码：</strong></p>
<p>在文件color_bias.py中，实现代码片段如下：</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506121011011.png"></p>
<h3 id="c行噪声">c)行噪声$N_{r}$<a hidden class="anchor" aria-hidden="true" href="#c行噪声">#</a></h3>
<p>原论文说是直接对bias frames进行离散傅里叶变换，这里我对曝光时间最小（Expo = 1/4000s）的bias frame进行DFT，用的np.fft，同时对明显的行噪声和列噪声（来源：网上找的例子）进行对比</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<blockquote>
<p>np.fft.fftshift的作用：通过将零频分量移动到数组中心，重新排列傅里叶变换的结果</p>
<p>我们知道：经过FFT之后，输出的频率范围是[0,fs]，但是，我们研究的范围一般是[-fs/2, fs/2]，也就是零频在中间，因此就需要将FFT的结果通过fftshift处理一下，将零频分量移到序列中间。</p></blockquote>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>Bias frame(1/4000s):</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>这么一对比，Canon M50拍出来的bias frames行噪声就不是很明显。</p>
<p><strong>具体实现代码：</strong></p>
<p>在文件row_noise.py中，实现代码片段如下：</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506121018169.png"></p>
<blockquote>
<p>在接下去之前，论文第六页在<strong>Estimate $\mu_c$​ for color bias</strong> 结尾处提到为了消除直流噪声对后续其他噪声参数估计的影响，先从暗场图像中减去每个颜色通道的平均值，这里我每个通道减去的值都取为2048</p></blockquote>
<p>行噪声服从均值为零的高斯分布：$N_r \sim \mathcal{N}(o, \sigma_r)$</p>
<p>关于参数$\sigma_r$ 是如何估计的：首先求出暗场图像每行的均值（这里论文的意思好像不需要减去黑电平也能求出$\sigma_r$），然后相应地就可以得到每一行的方差，最后行噪声就是由这么一组按行排列的高斯分布采样得到的信号值。关于这部分的实现原理去read_noise.py看代码实现会更清楚直观一些。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">######### Row noise parameters #########</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># extract mean values from each row</span>
</span></span><span style="display:flex;"><span>mu_row <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sum(raw_data, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> w
</span></span><span style="display:flex;"><span>mu_row2d <span style="color:#f92672">=</span> mu_row<span style="color:#f92672">.</span>reshape(h, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>mu_row_t <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>tile(mu_row2d, w)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># maximizing the log-likelihood</span>
</span></span><span style="display:flex;"><span>sigma2 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sum((raw_data <span style="color:#f92672">-</span> mu_row_t)<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> w
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">######################## Step 2: row noise image ######################</span>
</span></span><span style="display:flex;"><span>raw_row <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros((h, w), dtype<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>float64)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(h):
</span></span><span style="display:flex;"><span>    raw_row[i][:] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>normal(loc<span style="color:#f92672">=</span>mu_row[i], scale<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>sqrt(sigma2[i]), size<span style="color:#f92672">=</span>w)
</span></span></code></pre></div><h3 id="c-读噪声">c) 读噪声$N_{read}$<a hidden class="anchor" aria-hidden="true" href="#c-读噪声">#</a></h3>
<blockquote>
<p>补充下关于Probability Plot的知识：</p>
<p>The probability plot is a way of visually comparing the data coming from different distributions. These data can be of empirical dataset or theoretical dataset. The probability plot can be of two types:</p>
<ul>
<li><strong>P-P plot:</strong> The (Probability-to-Probability) p-p plot is the way to visualize the comparing of cumulative distribution function (CDFs) of the two distributions (empirical and theoretical) against each other.</li>
<li><strong>Q-Q plot:</strong> The q-q (Quantile-to-Quantile) plot is used to compare the quantiles of two distributions. The quantiles can be defined as continuous intervals with equal probabilities or dividing the samples between a similar way The distributions may be theoretical or sample distributions from a process, etc. The normal probability plot is a case of the q-q plot.</li>
</ul>
<p><strong>Normal Probability plot:</strong> The normal probability plot is a way of knowing whether the dataset is normally distributed or not. In this plot, data is plotted against the theoretical normal distribution plot in a way such that if a given dataset is normally distributed it should form an approximate straight line. The normal probability plot is a case of the probability plot (more specifically Q-Q plot). This plot is commonly used in the industry for finding the deviation from the normal process.</p>
<p><em>Source: <a href="https://www.geeksforgeeks.org/normal-probability-plot/">https://www.geeksforgeeks.org/normal-probability-plot/</a></em></p></blockquote>
<p><strong>1. Gaussian Probability Plot</strong></p>
<p><strong>Preprocess:</strong></p>
<p>用暗场图像先减去上一步的行噪声，然后为了加速运算，我在代码中取图像正中间一小块部分来运算（不求速度的话可以用整张图的数据去算分布），然后就可以画Q-Q图了。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>结果发现和正态分布拟合地很好，接下来看看和Tukey lambda分布拟合情况如何。</p>
<p><strong>2. Tukey Lambda PPCC Plot</strong></p>
<blockquote>
<p>补充知识：</p>
<p>*Reference: *</p>
<p><em>1.https://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ppccplot.htm</em></p>
<p><em>2.https://moonapi.com/news/4061.html</em></p>
<p><em>3.https://www.itl.nist.gov/div898/handbook/eda/section3/eda366f.htm</em></p></blockquote>
<blockquote>
<p>The <a href="https://www.itl.nist.gov/div898/handbook/eda/section3/eda366f.htm">Tukey Lambda</a> PPCC plot, with shape parameter <em>λ</em>, is particularly useful for symmetric distributions. It indicates whether a distribution is short or long tailed and it can further indicate several common distributions. Specifically:</p>
<ol>
<li><em>λ</em> = -1: distribution is approximately Cauchy</li>
<li><em>λ</em> = 0: distribution is exactly logistic</li>
<li><em>λ</em> = 0.14: distribution is approximately normal</li>
<li><em>λ</em> = 0.5: distribution is U-shaped</li>
<li><em>λ</em> = 1: distribution is exactly uniform</li>
</ol>
<p>If the Tukey Lambda PPCC plot gives a maximum value near 0.14, we can reasonably conclude that the normal distribution is a good model for the data. If the maximum value is less than 0.14, a long-tailed distribution such as the double exponential or logistic would be a better choice. If the maximum value is near -1, this implies the selection of very long-tailed distribution, such as the Cauchy. If the maximum value is greater than 0.14, this implies a short-tailed distribution such as the Beta or uniform.</p>
<p><em>Source: <a href="https://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ppccplot.htm">https://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ppccplot.htm</a></em></p></blockquote>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506121020749.png"></p>
<p>PPCC图可以用来求分布最符合的形状参数$\lambda$ ，结果如上：$\lambda = 0.164$ 表明了在Canon M50拍下的暗场图像呈短尾分布（$-1 <\lambda < 0.14$为长尾分布；$\lambda=0.14$呈完美的正态分布；$\lambda>0.14$​ 呈短尾分布）</p>
<blockquote>
<p>注意在用Tukey lambda分布估计数据分布时要事先画直方图看数据是否对称分布</p>
<p>As the Tukey-Lambda distribution is a symmetric distribution, the use of the Tukey-Lambda PPCC plot to determine a reasonable distribution to model the data only applies to symmetric distributions. A <a href="https://www.itl.nist.gov/div898/handbook/eda/section3/histogra.htm">histogram</a> <strong>of the data should provide evidence as to whether the data can be reasonably modeled with a symmetric distribution.</strong></p></blockquote>
<p><strong>3. Tukey Lambda Probability Plot</strong></p>
<p>由于在PPCC图中我们得到了关于暗场图像的分布形状参数，也就是shape_param_max，即shape_param_max = $\lambda = 0.164$ ，所以也就得到了形状参数为0.164的Tukey lambda分布来估计暗场图像的分布，标定完后续就可以用这个分布来建立数据集。</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506121021938.png"></p>
<p>用形状参数$\lambda = 0.164$ 的分布来拟合发现和正态分布的Probability Plot拟合程度$R^2$区别不大，所以读出噪声可以近似为正态分布；关于Tukey Lambda分布的拟合情况请看下图（这里Tukey Lambda分布的参数$\lambda$ 我取的是-0.14，即原论文中佳能EOS70D的参数来进行对比）：</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506121022845.png"></p>
<p>可以发现佳能M50的读出噪声对Tukey Lambda的分布拟合情况并不好，不如正态分布；不过发现在噪声极少的情况下（曝光时间30s，ISO为200），读出噪声更符合Tukey Lambda的分布，原因可能是当噪声变多后分布符合大数定律的原则。</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p><strong>具体实现代码：</strong></p>
<p>在文件read_noise.py中，实现代码片段如下：</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506121023817.png"></p>
<h3 id="d重建流程">d)重建流程<a hidden class="anchor" aria-hidden="true" href="#d重建流程">#</a></h3>
<p>这一步是为了模拟仿真出真实相机传感器中产生的各种噪声，也就是利用公式（10）复原上述所讲的各种噪声，然后进行ISP流程如：线性化&ndash;&gt;白平衡&ndash;&gt;去马赛克&ndash;&gt;颜色矫正&ndash;&gt;亮度拉伸/Gamma矫正，最后重建出一张噪声图。</p>
<p>首先通过直方图直观地看重建的噪声图和原暗场图像之间的差异：</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>图形差异挺大的，原因可能是在原暗场图像中存在不少离群点，那我们用数据差异来看二者之间差异多大；这里用的指标是$R^2$ 和KL散度，其中$R^2$ 作了一些处理（由于噪声是随机出现在图像不同像素点位置的，所以为了避免位置对数值上差异的干扰，代码中对两幅图像素值作了排序，这样算$R^2$ 才不会出现负值），结果如下：</p>
<p><strong>R2 for estimated model: 0.9972249549587314</strong></p>
<p><strong>KL-divergence: 0.0001303227610267369</strong></p>
<p>可以看出最后重建的效果不错，噪声图比较接近真实的暗场图像。</p>
<blockquote>
<p>关于为何在代码中为何不加入光子散粒噪声：</p>
<p>因为这里重建的是暗场图像，不受实际光子影响，所以没加。如果想在一幅真实环境下图像加噪声，此时就可以考虑光子散粒噪声$N_p$的影响了</p></blockquote>
<p>最后重建出来的效果如下（色调有点偏白，不过不是重建中出现的问题）：</p>
<p><img loading="lazy" src="https://zli1024-pictures.oss-cn-shenzhen.aliyuncs.com/imgs/202506121027495.png"></p>
<p>**具体实现代码：**在文件noise_img.py中可以直观地看每一步实现的细节</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://zli1024.github.io/tags/noise/">Noise</a></li>
      <li><a href="https://zli1024.github.io/tags/calibration/">Calibration</a></li>
      <li><a href="https://zli1024.github.io/tags/camera/">Camera</a></li>
      <li><a href="https://zli1024.github.io/tags/computational/">Computational</a></li>
      <li><a href="https://zli1024.github.io/tags/photography/">Photography</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://zli1024.github.io/posts/cmu10_725_hw2/">
    <span class="title">« Prev</span>
    <br>
    <span>CMU 10-725 HW2</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://zli1024.github.io/">Zhilin&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
const images = Array.from(document.querySelectorAll(".post-content img"));
images.forEach(img => {
  mediumZoom(img, {
    margin: 0,  
    scrollOffset: 40,  
    container: null,  
    template: null  
  });
});
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    document.querySelectorAll('mjx-container').forEach(el => {
      el.style.overflowX = 'auto';
      el.style.display = 'block';
      el.style.maxWidth = '100%';
      el.style.paddingBottom = '0.5em';
    });
  });
</script>
</body>

</html>
